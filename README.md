# 记录leetcode刷题
## array01.py
 * ### 1.两数之和:给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，返回他们的数组下标。
    - 解法：哈希表，时间复杂度：*O(N)*，空间复杂度：*O(N)*
    - 在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回
 * ### 11.盛最多水的容器：给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点(i,ai)。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai) 和 (i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。
    - 解法：双指针，时间复杂度：*O(N)*，空间复杂度：*O(1)*
    - 左右指针分别代表容器的边界，容纳的水为：min(height[left],height[right]) * (right-left)。判断height[left],height[right]的大小，移动较小的指针（因为不管移动那边指针，底的大小相同）。只遍历一遍数组，所以时间复杂度为N；只用了常数的变量，所以空间复杂度为1。
 * ### 15. 三数之和:给你一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。
    - 解法：排序 + 双指针，时间复杂度：*O(N<sup>2</sup>)*，空间复杂度：*O(N)*
    - 为了去掉重复的答案，先排序。a,b,c中，a需要从头遍历，b,c用双指针遍历，三数之和大于0，right减一，和减小；
        三数之和小于0，left加一，和增大；三数之和等于0，结果加入答案list
 * ### 16. 最接近的三数之和:给定一个包括n 个整数的数组nums和 一个目标值target。找出nums中的三个整数，使得它们的和与target最接近。返回这三个数的和。假定每组输入只存在唯一答案。
    - 解法：排序 + 双指针，时间复杂度：*O(N<sup>2</sup>)*，空间复杂度：*O(N)*
    - 先排序； a,b,c中，a需要从头遍历，b,c用双指针遍历，三数之和大于target，right减一，和减小；三数之和小于target，left加一，和增大；每次都计算与target的差，记录最小的，如果为0直接返回。
 * ### 18. 四数之和:给定一个包含n 个整数的数组nums和一个目标值target，判断nums中是否存在四个元素 a，b，c和 d，使得a + b + c + d的值与target相等？找出所有满足条件且不重复的四元组。
    - 解法：排序 + 双指针，时间复杂度：*O(N<sup>3</sup>)*，空间复杂度：*O(N)*
 * ### 26. 删除排序数组中的重复项:给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成
    - 解法：双指针，时间复杂度：*O(N)*，空间复杂度：*O(1)*
 * ### 27. 移除元素：给你一个数组 nums和一个值 val，你需要 原地 移除所有数值等于val的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素
    - 解法：双指针，时间复杂度：*O(N)*，空间复杂度：*O(1)*
    - left,right 分别从头和尾开始。将等于val的元素放到数组最后，right代表不等于val的最大值，当nums[left]等于val时left和right的值互换，left+1，right-1。当left==right说明数组已经遍历完且大于right的值都等于val，nums[left]！=val，返回left+1，nums[left]==val，返回left
 * ### 33. 搜索旋转排序数组：给你一个整数数组 nums ，和一个整数 target。该整数数组原本是按升序排列，但输入时在预先未知的某个点上进行了旋转。(例如，数组[0,1,2,4,5,6,7]可能变为[4,5,6,7,0,1,2])。请你在数组中搜索target ，如果数组中存在这个目标值，则返回它的索引，否则返回-1
    - 解法：二分法，时间复杂度：*O(log<sub>n</sub>)*，空间复杂度： *O(1)*
    - 左闭右闭。注意不是一般的排序数组，而是旋转，因此每次确定mid后比较left和right的值确定哪半个区间是排好序的，再分别判断舍弃区间
## array02.py
 * ### 34. 在排序数组中查找元素的第一个和最后一个位置：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是O(log n) 级别。
    - 解法：二分法，时间复杂度：*O(log<sub>n</sub>)*，空间复杂度： *O(1)*
    - 二分查找，左闭右开，另用一个标志位来改变边界条件分别查找第一个和最后一个目标位置
 * ### 35. 搜索插入位置：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。
    - 解法：二分法，时间复杂度：*O(log<sub>n</sub>)*，空间复杂度： *O(1)*
    - 二分查找，target可能不存在，因此left==right也要判断
 * ### 39. 组合总和：给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。candidates的数字可以无限制重复被选取。所有数字（包括 target）都是正整数。解集不能包含重复的组合
    - 解法：回溯算法
    1. 先排序，便于剪枝，即当余数小于0时及时跳出循环 
    2. 构建递归函数，调用自身前后分别添加和去掉元素
 * ### 40. 组合总和 II：给定一个数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。candidates 中的每个数字在每个组合中只能使用一次,所有数字（包括目标数）都是正整数,解集不能包含重复的组合
    - 解法：回溯算法
    1. 先排序，便于剪枝，即当余数小于0时及时跳出循环 
    2. 构建递归函数，调用自身前后分别添加和去掉元素
    3. 注意存在重复元素，但是不包含重复组合的要求
 * ### 48. 旋转图像：给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。
    - 时间复杂度*O(n<sup>2</sup>)*，空间复杂度*O(1)* 这里先对数组进行对角线翻转，再对数组前后左右翻转，即实现顺时针旋转90度
 * ### 53. 最大子序和：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和
    - 解法：动态规划，*O(n)*，空间复杂度*O(1)*
    - 用数组（或者一个变量）来表示 以 n 结尾 的 子数组最大和，那么pres[n] = max(pres[n-1]+nums[n], nums[n]).   res = max(pres)
 * ### 54. 螺旋矩阵：给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素
    - *O(mn)*，空间复杂度*O(mn)*
    - 顺时针旋转即left->right,top->bottom,right->left,bottom->top。注意区分 m > n 和 m < n 的结束情况
 * ### 55. 跳跃游戏：数组中的每个元素代表你在该位置可以跳跃的最大长度,判断你是否能够到达最后一个位置
    - 解法：贪心算法，*O(n)*，空间复杂度*O(1)*
 * ### 56. 合并区间：给出一个区间的集合，请合并所有重叠的区间
    - 时间复杂度*O(nlog(n))*，空间复杂度*O(log(n))*
    - 先对根据数组第一个元素对二维数组排序，根据规则合并区间
 * ### 59. 螺旋矩阵 II：给定一个正整数 n，生成一个包含 1 到 n<sup>2</sup> 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵
    - 时间复杂度*O(n<sup>2</sup>)*，空间复杂度*O(n<sup>2</sup>)*
    - 顺时针即left->right,top->bottom,right->left,bottom->top
## array03.py
 * ### 62. 不同路径：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径。
    - 解法：动态规划，时间复杂度：*O(MN)*，空间复杂度：*O(MN)* => *O(M)*
    - m*n大小的数组res用来保存到每一个格子的路径，某个格子只能由它上边一个格子或者左边一个的移动而来，即res(i,j) = res(i-1,j) + res(i,j-1) 遍历所有格子，最后返回右下角的值就是答案，空间复杂度可以优化值O(N)
 * ### 63. 不同路径 II：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。问总共有多少条不同的路径。
    - 解法：动态规划，时间复杂度：*O(MN)*，空间复杂度：*O(MN)* => *O(M)*
    - m*n大小的数组res用来保存到每一个格子的路径，某个格子只能由它上边一个格子或者左边一个的移动而来，即res(i,j) = res(i-1,j) + res(i,j-1) 遍历所有格子，最后返回右下角的值就是答案，空间复杂度可以优化值O(M)
 * ### 64. 最小路径和：给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步
    - 解法：动态规划，时间复杂度：*O(MN)*，空间复杂度：*O(MN)* => *O(M)*
    - m*n大小的数组res用来保存到每一个格子的路径，res(i,j) = grid(i,j) + min(res(i-1,j), res(i,j-1)) 遍历所有格子，最后返回右下角的值就是答案，空间复杂度可以优化值O(M)
 * ### 66. 加一：给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头
    - 注意进位
 * ### 73. 矩阵置零：给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法
    - 时间复杂度：O(mn)，空间复杂度：O(m+n)
    - 分别用两个集合记录要置零的 行 和 列 第一次遍历记录，第二次遍历置零
 * ### 74. 搜索二维数组：编写一个高效的算法来判断m x n矩阵中，是否存在一个目标值。该矩阵具有如下特性：每行中的整数从左到右按升序排列。每行的第一个整数大于前一行的最后一个整数。
    - 解法：二分查找，时间复杂度：O(log(mn))，空间复杂度：O(1)
 * ### 75. 颜色分类：给定一个包含红色、白色和蓝色，一共n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、1 和 2 分别表示红色、白色和蓝色。
    - 解法：双指针，时间复杂度：O(n)，空间复杂度：O(1)
    - left 之前是确定的0，right之后是确定的2，curr遍历数组
 * ### 78. 子集：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）
    - 解法：回溯算法，时间复杂度：O(n×2<sup>n</sup>)，空间复杂度：O(n)
    - 因为不含重复元素可以不排序，子集的大小可能是0（空集）size（全集）因此需要遍历0-size
 * ### 79. 单词搜索:给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
    - 解法：深度优先搜寻
    - [官方解法](https://leetcode-cn.com/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/)
 * ### 80. 删除排序数组中的重复项 II：给定一个增序排列数组 nums ，你需要在 原地 删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
    - 解法：双指针，时间复杂度：O(n)，空间复杂度：O(1)
    - 双指针font, nex，分别用于遍历数组和确定去重后位置，count计数不大于2